---
layout: post
title: 深入 Java 热部署系列
categories: [Java]
description: 熟练的 Java 工具包有助于开发....................................................................................................................................................................................................
keywords: 热部署,Java
---
# 热部署
在 Java 开发领域，热部署一直是一个难以解决的问题，目前的 Java 虚拟机只能实现方法体的修改热部署，对于整个类的结构修改，仍然需要重启虚拟机，对类重新加载才能完成更新操作。对于某些大型的应用来说，每次的重启都需要花费大量的时间成本。虽然 osgi 架构的出现，让模块重启成为可能，但是如果模块之间有调用关系的话，这样的操作依然会让应用出现短暂的功能性休克。本文将探索如何在不破坏 Java 虚拟机现有行为的前提下，实现某个单一类的热部署，让系统无需重启就完成某个类的更新。

## 一.成熟的热部署技术实现原理
首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 `classloader` 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 `classloader` 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。

另一种友好的方法是创建自己的 `classloader` 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。本文将具体探索如何实现这个方案。首先需要了解一下 Java 虚拟机现有的加载机制。目前的加载机制，称为双亲委派，系统在使用一个 `classloader` 来加载类时，会先询问当前 `classloader` 的父类是否有能力加载，如果父类无法实现加载操作，才会将任务下放到该 `classloader` 来加载。这种自上而下的加载方式的好处是，让每个 `classloader` 执行自己的加载任务，不会重复加载类。但是这种方式却使加载顺序非常难改变，让自定义 `classloader` 抢先加载需要监听改变的类成为了一个难题。

不过我们可以换一个思路，虽然无法抢先加载该类，但是仍然可以用自定义  `classloader` 创建一个功能相同的类，让每次实例化的对象都指向这个新的类。当这个类的 class 文件发生改变的时候，再次创建一个更新的类，之后如果系统再次发出实例化请求，创建的对象讲指向这个全新的类。

**下面来简单列举一下需要做的工作。**

1. 创建自定义的 `classloader`，加载需要监听改变的类，在 class 文件发生改变的时候，重新加载该类。
2. 改变创建对象的行为，使他们在创建时使用自定义 `classloader` 加载的 class。

### 1.自定义加载器的实现
利用 ASM 修改 class 文件

### 2.改变创建对象的行为
Java 虚拟机常见的创建对象的方法有两种，一种是静态创建，直接 new 一个对象，一种是动态创建，通过反射的方法，创建对象。

由于已经在自定义加载器中更改了原有类的类型，把它从类改成了接口，所以这两种创建方法都无法成立。我们要做的是将实例化原始类的行为变成实例化派生类。



### 3.使用 JavaAgent 拦截默认加载器的行为
之前实现的类加载器已经解决了热部署所需要的功能，可是 JVM 启动时，并不会用自定义的加载器加载 classpath 下的所有 class 文件，取而代之的是通过应用加载器去加载。如果在其之后用自定义加载器重新加载已经加载的 class，有可能会出现 LinkageError 的 exception。所以必须在应用启动之前，重新替换已经加载的 class。如果在 jdk1.4 之前，能使用的方法只有一种，改变 jdk 中 classloader 的加载行为，使它指向自定义加载器的加载行为。好在 jdk5.0 之后，我们有了另一种侵略性更小的办法，这就是 JavaAgent 方法，JavaAgent 可以在 JVM 启动之后，应用启动之前的短暂间隙，提供空间给用户做一些特殊行为。比较常见的应用，是利用 JavaAgent 做面向方面的编程，在方法间加入监控日志等。

## 二.HotSwap 和 JRebel 中间件原理对比

### 1.HotSwap
在2002年的时候，Sun 在 Java 1.4的JVM中引入了一种新的被称作HotSwap的实验性技术，这一技术被合成到了Debugger API内部，其允许调试者使用同一个类标识来更新类的字节码。这意味着所有对象都可以引用一个更新后的类，并在它们的方法被调用的时候执行新的代码，这就避免了无论何时只要有类的字节码被修改就要重载容器的这种要求。所有新式的IDE（包括Eclipse、IDEA和NetBeans）都支持这一技术，从Java 5开始，这一功能还通过Instrumentation API直接提供给Java应用使用。

#### 1.1 HotSwap 缺点
不幸的是，这种重定义仅限于修改方法体——除了方法体之外，它既不能添加方法或域，也不能修改其他任何东西。这限制了HotSwap的实用性，且其还因其他的一些问题而变得更糟：
> Java编译器常常会创建合成的方法或是域，尽管你仅是修改了一个方法体（比如说，在添加一个类字面常量（class literal）、匿名的和内部的类的时候等等）。 在调试模式下运行常常会降低应用的速度或是引入其他的问题。


### 2.JRebel
2007年，ZeroTurnaround宣布提供一种被称作JRebel（当时是JavaRebel）的工具，该工具可以在无需动态类加载器的情况下更新类，且只做极少的限制。不像HotSwap要依赖于IDE的集成，这一工具的工作方式是，监控磁盘上实际已编译的.class文件，无论何时只要有文件被更新就更新类。这意味着如果愿意的话，你可以把JRebel和文本编辑器、命令行的编译器放在一起使用。当然，它也被巧妙地整合到了Eclipse、InteliJ和NetBeans中。与动态的类加载器不一样，JRebel保留了所有现有的对象和类的标识和状态，允许开发者继续使用他们的应用而不会产生延迟。

#### 2.1 JRebel 相对于 HotSwap 的不同之处
鉴于HotSwap是工作在虚拟机层面上，且依赖于JVM的内部运作，JRebel用到了JVM的两个显著的功能特征——抽象的字节码和类加载器。类加载器允许JRebel辨别出类被加载的时刻，然后实时地翻译字节码，用以在虚拟机和可执行代码之间创建另一个抽象层。

基于先进的编译技术，留给我们一个主类和几个匿名的支持类，这些类由JIT的转换运行时做支持，其允许所进行的修改不会带来任何明显的性能或是兼容性的退化。它还留有尽可能多完整的方法调用，这意味着JRebel把性能开销降低到了最小，使其轻量级化。
避免了改编（instrument）Java SDK，除了少数几个需要保持兼容性的地方外。
调整Reflection API的结果，这样我们就能够把这些结果中已添加/已删除的成员正确地包含进来。这也意味着注解（Annotation）的改变对于应用来说是可见的。

**所以更加推崇 JRebel** 

## 三.Tomcat的热部署的分析
详细类容分析,查看链接 [class卸载、热替换和Tomcat的热部署的分析](#jump)

## 四.参考链接
1. [深入探索 Java 热部署](http://www.ibm.com/developerworks/cn/java/j-lo-hotdeploy/)
2. [HotSwap和JRebel原理](http://article.yeeyan.org/view/213582/186226)
3. <span id="jump"></span> [class卸载、热替换和Tomcat的热部署的分析](http://www.blogjava.net/heavensay/archive/2012/11/07/389685.html)